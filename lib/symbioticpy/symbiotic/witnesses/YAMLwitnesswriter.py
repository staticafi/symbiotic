#!/usr/bin/env python3

import clang.cindex
from hashlib import sha256 as hashfunc
import datetime
import yaml
import sys
from .. utils.utils import print_stderr
import uuid
from ..options import get_versions

def get_hash(source):
    f = open(source, 'r', encoding='utf-8')
    hsh = hashfunc()
    for l in f:
        hsh.update(l.encode('utf-8'))

    f.close()
    return hsh.hexdigest()

class YAMLWriter(object):
    def __init__(self, source, prps, is32bit, is_correctness_wit):
        self._source = source
        self._prps = prps
        self._is32bit = is32bit
        self._correctness_wit = is_correctness_wit

        self.test = []
        self.errorLoc = None
        self.errorExpr = None
        self.calls = dict()
        self.witness = []

    def add_metadata(self):
        witness = {}
        witness['entry_type'] = "violation_sequence" if not self._correctness_wit else "invariant_set"
        witness['metadata'] = {
            'format_version' : "2.0",
            'creation_time' :  '{date:%Y-%m-%dT%T}Z'.format(date=datetime.datetime.utcnow()),
            'producer' : {'name' : 'symbiotic',
                          'version' : get_versions()[0] },
            'uuid' : str(uuid.uuid4()),
            'task' :
                { 'input_files' : [self._source],
                  'input_file_hashes' : { self._source : get_hash(self._source)},
                  'specification' : ','.join(self._prps),
                  'data_model' : "ILP32" if self._is32bit else "LP64",
                  'language' : "C"}
        }
        self.witness.append(witness)


    def generate_violation_witness(self, path):
        """
        Take a .test file generated by a tool and generate a new
        .yml file from it that has all the needed metadata.

        \param path         the .waypoints file
        """

        self.parse(path)
        assert self.errorLoc, "Failed generating a YAML witness"

        self.add_metadata()
        self.create_content()


    def generate_correctness_witness(self):
        self.add_metadata()

        # So far we can only create trivial correctness witnesses
        self.witness[0]['content'] = []

    def dump(self):
        print(self.witness)

    def write(self, to):
        with open(to, "w") as witness_file:
            yaml.safe_dump(self.witness, witness_file, default_style=None)



    # Traverse the AST, find the right brackets of functions and the full expression of the target
    def traverse_AST(self, node):
        # Recurse for children of this node

        for child in node.get_children():

            if not child.location.file or child.location.file.name != self._source:
                continue

            start = child.extent.start
            end = child.extent.end

            if child.kind == clang.cindex.CursorKind.CALL_EXPR and (start.line, start.column) in self.calls:
                self.calls[(start.line, start.column)] = end.line, end.column - 1

            if self.errorExpr or not child.kind.is_expression():
                self.traverse_AST(child)
                continue

            # check range of the expression
            err_line = self.errorLoc[0]
            err_col = self.errorLoc[1]
            if not self.errorExpr and location_in_range(err_line, err_col, \
                                                        start.line, start.column, \
                                                        end.line, end.column):
                self.errorExpr = start.line, start.column
            self.traverse_AST(child)



    def create_content(self):
        sys.setrecursionlimit(2048)

        index = clang.cindex.Index.create()
        tu = index.parse(self._source, args=['-fbracket-depth=2048'])
        root = tu.cursor
        self.traverse_AST(root)

        if not self.errorExpr:
            print_stderr("Warning: Could not get target location for witness")

        content = []

        for call in self.test:
            new_location = self.calls[(call[0], call[1])]
            assert new_location, "Failed creating witness"

            segment = []
            waypoint = { 'type' : 'function_return',
                          'action' : 'follow',
                          'constraint' : {
                            'format' : 'c_expression',
                            'value' : '\\result == ' + call[2]
                          },
                          'location' : {
                            'file_name' : self._source,
                            'line' : new_location[0],
                            'column' : new_location[1]
                          }

                        }
            segment.append({'waypoint' : waypoint})
            content.append({'segment' : segment})

        target_segment = []
        target = { 'type' : 'target',
                   'action' : 'follow',
                   'location' : {
                            'file_name' : self._source,
                            'line' : self.errorExpr[0],
                            'column' : self.errorExpr[1]
                          }

                 }

        target_segment.append({'waypoint' : target})
        content.append({'segment' : target_segment})

        self.witness[0]['content'] = content


    def parse(self, path):
        with open(path, "r") as testfile:
            for line in testfile.readlines():
                if line[0] == '@':
                    self.errorLoc = list(map(int, line.strip('\n').split(':')[2:]))
                    break
                call = line.strip('\n').split(':')
                line = int(call[1])
                col = int(call[2])
                value = call[3]
                self.test.append((line, col, value))
                self.calls[(line, col)] = None

def location_in_range(line, col, startline, startcol, endline, endcol):

    if startline > line or endline < line:
        return False

    if startline == line and startcol > col:
        return False

    if endline == line and endcol < col:
        return False

    return True
